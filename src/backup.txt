#include <stdlib.h>  // for EXIT_SUCCESS
#include <memory>    // for allocator, __shared_ptr_access
#include <string>  // for string, operator+, basic_string, to_string, char_traits
#include <vector>  // for vector, __alloc_traits<>::value_type
#include <cstring>

#include "ftxui/component/captured_mouse.hpp"  // for ftxui
#include "ftxui/component/component.hpp"  // for Menu, Renderer, Horizontal, Vertical
#include "ftxui/component/component_base.hpp"  // for ComponentBase
#include "ftxui/component/screen_interactive.hpp"  // for Component, ScreenInteractive
#include "ftxui/dom/elements.hpp"  // for text, Element, operator|, window, flex, vbox
 

#include <gio/gio.h>
#include <uuid/uuid.h>
#include <nm-dbus-interface.h>
#include <NetworkManager.h>

using namespace ftxui;

const std::string DEV_TYPE_NAME[21] {
            "",
            "Ethernet",
            "Wi-Fi",
            "Bluetooth",
            "OLPC",
            "WiMAX",
            "Modem",
            "InfiniBand",
            "Bond",
            "VLAN",
            "ADSL",
            "Bridge",
            "Generic",
            "Team",
            "TUN",
            "IPTunnel",
            "MACVLAN",
            "VXLAN",
            "Veth",
            "Unknown"
};

struct network_device {
    std::string obj_path;
    std::string dev_type;
};

struct wireless_struct {
    std::string obj_dir;
    std::string ssid;
    int strength;
};

class NewtworkManager{
private:
    int num_device;
    int device_path_num;
    std::vector<std::string> device_paths;
    std::vector<std::string> device_types;
    std::vector<wireless_struct> access_points;

public:
    NewtworkManager() {
        num_device = 0;
        read_device_paths();
        read_device_types();
        read_wireless_accesspoints();
    }

    ~NewtworkManager() {

    }

    void read_device_paths(){
        GDBusProxy *props_proxy;
        GError *  error = NULL;
        GVariant *ret = NULL, *value = NULL;
        char ** paths = NULL;

        /* Create a D-Bus proxy to get the object properties from the NM Manager
        * object.  NM_DBUS_* defines are from nm-dbus-interface.h.
        */
        props_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                                    G_DBUS_PROXY_FLAGS_NONE,
                                                    NULL,
                                                    NM_DBUS_SERVICE,
                                                    NM_DBUS_PATH,
                                                    "org.freedesktop.DBus.Properties",
                                                    NULL,
                                                    NULL);
        g_assert(props_proxy);

        /* Get the ActiveConnections property from the NM Manager object */
        ret = g_dbus_proxy_call_sync(props_proxy,
                                    "Get",
                                    g_variant_new("(ss)", NM_DBUS_INTERFACE, "AllDevices"),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);

        if (!ret) {
            g_dbus_error_strip_remote_error(error);
            g_warning("Failed to get AllDevices property: %s\n", error->message);
            g_error_free(error);
            return;
        }

        g_variant_get(ret, "(v)", &value);

        /* Make sure the ActiveConnections property is the type we expect it to be */
        if (!g_variant_is_of_type(value, G_VARIANT_TYPE("ao"))) {
            g_warning("Unexpected type returned getting AllDevices: %s",
                    g_variant_get_type_string(value));
            if (value)
                g_variant_unref(value);
            if (ret)
                g_variant_unref(ret);
        }

        /* Extract the active connections array from the GValue */
        paths = g_variant_dup_objv(value, NULL);

        if (!paths) {
            g_warning("Could not retrieve active connections property");
            if (value)
                g_variant_unref(value);
            if (ret)
                g_variant_unref(ret);
        }

        for (int i = 0; paths[i]; i++) {
            device_paths.push_back(paths[i]);
            num_device++;
        }

        g_strfreev(paths);
    }

    void read_device_types() {
        GDBusProxy *props_proxy;
        GVariant *  ret = NULL, * path_value = NULL;
        GError *    error = NULL;
        int dev_type_int;

        for (int i = 0; i < num_device; i++) {
            int n = device_paths[i].length();
            char char_array[n + 1];
            strcpy(char_array, device_paths[i].c_str());

            props_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                        G_DBUS_PROXY_FLAGS_NONE,
                                        NULL,
                                        NM_DBUS_SERVICE,
                                        char_array,
                                        "org.freedesktop.DBus.Properties",
                                        NULL,
                                        NULL);

            g_assert(props_proxy);
            
            ret = g_dbus_proxy_call_sync(props_proxy,
                                        "Get",
                                        g_variant_new("(ss)", NM_DBUS_INTERFACE_DEVICE, "DeviceType"),
                                        G_DBUS_CALL_FLAGS_NONE,
                                        -1,
                                        NULL,
                                        &error);

            g_variant_get(ret, "(v)", &path_value);
            dev_type_int = g_variant_get_uint32(path_value);
            device_types.push_back(DEV_TYPE_NAME[dev_type_int]);

            g_variant_unref(ret);
        }
    }

    void read_access_point_detail(const char *path, char *ssid_name)
    {
        GDBusProxy * proxy;
        GError *     error = NULL;
        GVariant *   ret;
        GVariant * path_value;
        // const char * id, *type;
        // gboolean     found;
        // GVariantIter iter;
        // const char * setting_name;
        GVariantIter iter;
        char paths;
        /* This function asks NetworkManager for the details of the connection */

        /* Create the D-Bus proxy so we can ask it for the connection configuration details. */
        proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                            G_DBUS_PROXY_FLAGS_NONE,
                                            NULL,
                                            NM_DBUS_SERVICE,
                                            path,
                                            "org.freedesktop.DBus.Properties",
                                            NULL,
                                            NULL);
        g_assert(proxy);

        /* Request the all the configuration of the Connection */
        ret = g_dbus_proxy_call_sync(proxy,
                                    "Get",
                                    g_variant_new("(ss)", NM_DBUS_INTERFACE_ACCESS_POINT, "Ssid"),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        if (!ret) {
            g_dbus_error_strip_remote_error(error);
            g_warning("Failed to get Ssid: %s\n", error->message);
            g_error_free(error);
            return;
        }

        g_variant_get(ret, "(v)", &path_value);

        g_variant_iter_init(&iter, path_value);

        int len = 0;
        while (g_variant_iter_next(&iter, "y", &paths)) {
            ssid_name[len++] = paths;
            g_print("%c", paths);
        }
        ssid_name[len] = '\0';
        g_print("\n");

        if (path_value)
            g_variant_unref(path_value);
        if (ret)
            g_variant_unref(ret);
    }

    void read_wireless_accesspoints() {
        GDBusProxy *props_proxy;
        GVariant *  ret = NULL;
        GError *    error = NULL;

        int       i;
        char **   paths;

        // Get wireless device path
        for (int i = 0; i < device_paths.size(); i++) {
            if (device_types[i].compare(DEV_TYPE_NAME[2]) == 0)
                device_path_num = i;
        }

        int n = device_paths[device_path_num].length();
        char dev_path[n + 1];
        strcpy(dev_path, device_paths[device_path_num].c_str());

        props_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                                G_DBUS_PROXY_FLAGS_NONE,
                                                NULL,
                                                NM_DBUS_SERVICE,
                                                dev_path,
                                                NM_DBUS_INTERFACE_DEVICE_WIRELESS,
                                                NULL,
                                                NULL);
        g_assert(props_proxy);

        ret = g_dbus_proxy_call_sync(props_proxy,
                                    "GetAllAccessPoints",
                                    NULL,
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        
        if (!ret) {
            g_dbus_error_strip_remote_error(error);
            g_print("ListConnections failed: %s\n", error->message);
            g_error_free(error);
            return;
        }

        g_variant_get(ret, "(^ao)", &paths);
        g_variant_unref(ret);

        for (i = 0; paths[i]; i++) {
            wireless_struct w_obj;
            char ssid[225];
            read_access_point_detail(paths[i], ssid);
            w_obj.obj_dir = paths[i];
            w_obj.ssid = ssid;
            access_points.push_back(w_obj);
        }
    }

    void connect_wireless(const int num_ap, const std::string password) {
        GVariantBuilder connection_builder;
        GVariantBuilder setting_builder;
        char *          uuid;
        const char *    new_con_path;
        GVariant *      ret, *ret2, *value;
        GError *        error = NULL;
        GDBusProxy *proxy, *proxy2;

        int n = (access_points[num_ap].obj_dir).length();
        char dev_path[n + 1];
        strcpy(dev_path, (access_points[num_ap].obj_dir).c_str());
        g_print("%s\n", dev_path);

        n = (access_points[num_ap].ssid).length();
        char ssid_char[n + 1];
        strcpy(ssid_char, (access_points[num_ap].ssid).c_str());
        g_print("%s\n", ssid_char);

        n = password.length();
        char password_char[n + 1];
        strcpy(password_char, password.c_str());
        g_print("%s\n", password_char);

        proxy2 = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                          G_DBUS_PROXY_FLAGS_NONE,
                                          NULL,
                                          NM_DBUS_SERVICE,
                                          dev_path,
                                          "org.freedesktop.DBus.Properties",
                                          NULL,
                                          NULL);

        g_assert(proxy2);

        /* Request the all the configuration of the Connection */
        ret2 = g_dbus_proxy_call_sync(proxy2,
                                    "Get",
                                    g_variant_new("(ss)", NM_DBUS_INTERFACE_ACCESS_POINT, "Ssid"),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        if (!ret2) {
            g_dbus_error_strip_remote_error(error);
            g_warning("Failed to get Ssid: %s\n", error->message);
            g_error_free(error);
            return;
        }

        g_variant_get(ret2, "(v)", &value);

        /* Create a D-Bus proxy; NM_DBUS_* defined in nm-dbus-interface.h */
        proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                            G_DBUS_PROXY_FLAGS_NONE,
                                            NULL,
                                            NM_DBUS_SERVICE,
                                            NM_DBUS_PATH_SETTINGS,
                                            NM_DBUS_INTERFACE_SETTINGS,
                                            NULL,
                                            &error);
        if (!proxy) {
            g_dbus_error_strip_remote_error(error);
            g_print("Could not create NetworkManager D-Bus proxy: %s\n", error->message);
            g_error_free(error);
            return;
        }

        /* Initialize connection GVariantBuilder */
        g_variant_builder_init(&connection_builder, G_VARIANT_TYPE("a{sa{sv}}"));

        /* Build up the 'connection' Setting */
        g_variant_builder_init(&setting_builder, G_VARIANT_TYPE("a{sv}"));

        uuid = nm_utils_uuid_generate();
        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_CONNECTION_UUID,
                            g_variant_new_string(uuid));
        g_free(uuid);

        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_CONNECTION_ID,
                            g_variant_new_string(ssid_char));

        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_CONNECTION_TYPE,
                            g_variant_new_string(NM_SETTING_WIRELESS_SETTING_NAME));

        g_variant_builder_add(&connection_builder,
                            "{sa{sv}}",
                            NM_SETTING_CONNECTION_SETTING_NAME,
                            &setting_builder);

        /* Add the (empty) 'wired' Setting */
        g_variant_builder_init(&setting_builder, G_VARIANT_TYPE("a{sv}"));
        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_WIRELESS_SSID,
                            value);

        g_variant_builder_add(&connection_builder,
                            "{sa{sv}}",
                            NM_SETTING_WIRELESS_SETTING_NAME,
                            &setting_builder);

        /* Build up the 'Password' Setting */
        g_variant_builder_init(&setting_builder, G_VARIANT_TYPE("a{sv}"));
        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_WIRELESS_SECURITY_KEY_MGMT,
                            g_variant_new_string("wpa-psk"));
        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_WIRELESS_SECURITY_PSK,
                            g_variant_new_string(password_char));

        g_variant_builder_add(&connection_builder,
                            "{sa{sv}}",
                            NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
                            &setting_builder);

        /* Build up the 'ipv4' Setting */
        g_variant_builder_init(&setting_builder, G_VARIANT_TYPE("a{sv}"));
        g_variant_builder_add(&setting_builder,
                            "{sv}",
                            NM_SETTING_IP_CONFIG_METHOD,
                            g_variant_new_string(NM_SETTING_IP4_CONFIG_METHOD_AUTO));
        g_variant_builder_add(&connection_builder,
                            "{sa{sv}}",
                            NM_SETTING_IP4_CONFIG_SETTING_NAME,
                            &setting_builder);

        /* Call AddConnection with the connection dictionary as argument.
        * (g_variant_new() will consume the floating GVariant returned from
        * &connection_builder, and g_dbus_proxy_call_sync() will consume the
        * floating variant returned from g_variant_new(), so no cleanup is needed.
        */
        ret = g_dbus_proxy_call_sync(proxy,
                                    "AddConnection",
                                    g_variant_new("(a{sa{sv}})", &connection_builder),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        if (ret) {
            g_variant_get(ret, "(&o)", &new_con_path);
            g_print("Added: %s\n", new_con_path);
            g_variant_unref(ret);
        } else {
            g_dbus_error_strip_remote_error(error);
            g_print("Error adding connection: %s\n", error->message);
            g_clear_error(&error);
        }

        if (proxy) {
            g_object_unref(proxy);
        }
        if (proxy2) {
            g_object_unref(proxy2);
        }
        if (value) {
            g_variant_unref(value);
        }
    }

    void disconnect_wireless() {
        GDBusProxy *props_proxy;
        GError *     error = NULL;
        GVariant *   ret;

        int n = device_paths[device_path_num].length();
        char dev_path[n + 1];
        strcpy(dev_path, device_paths[device_path_num].c_str());

        /* Create a D-Bus proxy to get the object properties from the NM Manager
        * object.  NM_DBUS_* defines are from nm-dbus-interface.h.
        */
        props_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                                    G_DBUS_PROXY_FLAGS_NONE,
                                                    NULL,
                                                    NM_DBUS_SERVICE,
                                                    dev_path,
                                                    "org.freedesktop.NetworkManager.Device",
                                                    NULL,
                                                    NULL);
        g_assert(props_proxy);

        ret = g_dbus_proxy_call_sync(props_proxy,
                                    "Disconnect",
                                    NULL,
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);

        if (ret)
            g_variant_unref(ret);

        g_object_unref(props_proxy);
    }

    void activate_wireless() {
        GDBusProxy *props_proxy;
        GError *     error = NULL;
        GVariant *   ret;
        char * new_con_path;

        int n = device_paths[device_path_num].length();
        char dev_path[n + 1];
        strcpy(dev_path, device_paths[device_path_num].c_str());

        /* Create a D-Bus proxy to get the object properties from the NM Manager
        * object.  NM_DBUS_* defines are from nm-dbus-interface.h.
        */
        props_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                                    G_DBUS_PROXY_FLAGS_NONE,
                                                    NULL,
                                                    NM_DBUS_SERVICE,
                                                    "/org/freedesktop/NetworkManager",
                                                    "org.freedesktop.NetworkManager",
                                                    NULL,
                                                    NULL);
        
        g_assert(props_proxy);

        ret = g_dbus_proxy_call_sync(props_proxy,
                                    "ActivateConnection",
                                    g_variant_new("(ooo)", "/", dev_path, "/"),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        if (ret) {
            g_variant_get(ret, "(&o)", &new_con_path);
            g_print("Added: %s\n", new_con_path);
            g_variant_unref(ret);
        } else {
            g_dbus_error_strip_remote_error(error);
            g_print("Error adding connection: %s\n", error->message);
            g_clear_error(&error);
        }

        g_object_unref(props_proxy);
    }

    ///* Find Wi-Fi device to scan on. When no ifname is provided, the first Wi-Fi is used. */
    void wifi_scan(){
        GDBusProxy *props_proxy;
        GError *     error = NULL;
        GVariant *   ret, *value;
        int64_t time_before, time_after;

        int n = device_paths[device_path_num].length();
        char dev_path[n + 1];
        strcpy(dev_path, device_paths[device_path_num].c_str());

        /* Create a D-Bus proxy to get the object properties from the NM Manager
        * object.  NM_DBUS_* defines are from nm-dbus-interface.h.
        */
        props_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,
                                                    G_DBUS_PROXY_FLAGS_NONE,
                                                    NULL,
                                                    NM_DBUS_SERVICE,
                                                    dev_path,
                                                    "org.freedesktop.DBus.Properties",
                                                    NULL,
                                                    NULL);
        
        g_assert(props_proxy);

        ret = g_dbus_proxy_call_sync(props_proxy,
                                    "Get",
                                    g_variant_new("(ss)", "org.freedesktop.NetworkManager.Device.Wireless", "LastScan"),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        if (ret) {
            g_variant_get(ret, "(v)", &value);
            time_before = g_variant_get_int64(value);
            g_print("Added: %ld\n", time_before);
            g_variant_unref(ret);
        } else {
            g_dbus_error_strip_remote_error(error);
            g_print("Error adding connection: %s\n", error->message);
            g_clear_error(&error);
        }

        
        system("nmcli device wifi rescan");

        sleep(100);

        ret = g_dbus_proxy_call_sync(props_proxy,
                                    "Get",
                                    g_variant_new("(ss)", "org.freedesktop.NetworkManager.Device.Wireless", "LastScan"),
                                    G_DBUS_CALL_FLAGS_NONE,
                                    -1,
                                    NULL,
                                    &error);
        if (ret) {
            g_variant_get(ret, "(v)", &value);
            time_after = g_variant_get_int64(value);
            g_print("Added: %ld\n", time_after);
            g_variant_unref(ret);
        } else {
            g_dbus_error_strip_remote_error(error);
            g_print("Error adding connection: %s\n", error->message);
            g_clear_error(&error);
        }

        if (time_after != time_before) {
            g_print("Changed\n");
        }
        g_object_unref(props_proxy);
    }

    const std::vector<std::string> get_devicePaths() {
        return device_paths;
    }

    const std::vector<std::string> get_deviceTypes() {
        return device_types;
    }

    const std::vector<wireless_struct> get_accessPoints() {
        return access_points;
    }
};
 
int main(int argc, const char* argv[]) {

    NewtworkManager nm{};

    std::vector<wireless_struct> accessPoints = nm.get_accessPoints();

    for (int i = 0; i < accessPoints.size(); i++) {
        std::cout << accessPoints[i].obj_dir << "\t";
        std::cout << accessPoints[i].ssid << "\n";
    }

    nm.wifi_scan();
    // nm.disconnect_wireless();

    // nm.activate_wireless();

    // int num;
    // std::cout << "Which to connect\n";
    // std::cin >> num;

    // nm.connect_wireless(num, "dehua1218wen");
}   
 
// Copyright 2020 Arthur Sonzogni. All rights reserved.
// Use of this source code is governed by the MIT license that can be found in
// the LICENSE file.